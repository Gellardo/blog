<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Frank&#39;s Blog</title>
    <link>https://gellardo.github.io/blog/posts/</link>
    <description>Recent content in Posts on Frank&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 26 Sep 2022 11:30:00 +0200</lastBuildDate>
    
	<atom:link href="https://gellardo.github.io/blog/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Fixing my GRUB install</title>
      <link>https://gellardo.github.io/blog/posts/2022-09-26-fixing-grub/</link>
      <pubDate>Mon, 26 Sep 2022 11:30:00 +0200</pubDate>
      
      <guid>https://gellardo.github.io/blog/posts/2022-09-26-fixing-grub/</guid>
      <description>&lt;p&gt;After another instance of my Laptop no longer &amp;ldquo;working&amp;rdquo; after a firmware update, I decided to write down how to recover so I know where to look for it.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Tip: Spawn an interactive Python Shell anywhere in your code</title>
      <link>https://gellardo.github.io/blog/posts/2022-09-26-tip-python-shell/</link>
      <pubDate>Mon, 26 Sep 2022 10:15:00 +0200</pubDate>
      
      <guid>https://gellardo.github.io/blog/posts/2022-09-26-tip-python-shell/</guid>
      <description>&lt;p&gt;This is post is a collection of useful commands I always have to google for whenever I play around with new APIs/libraries.
Having an interactive shell to explore is incredibly helpful.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Validate GitLab Repository Configuration With Semgrep</title>
      <link>https://gellardo.github.io/blog/posts/2021-09-17-validate-repo-config-with-semgrep/</link>
      <pubDate>Fri, 17 Sep 2021 22:37:06 +0200</pubDate>
      
      <guid>https://gellardo.github.io/blog/posts/2021-09-17-validate-repo-config-with-semgrep/</guid>
      <description>Imagine this: You are migrating 50+ Repositories to a new GitLab instance. In addition to changing CI from Jenkins to GitLab CI, you are also trying to enforce a certain set of best practices like &amp;ldquo;don&amp;rsquo;t allow people to force-push the main branch&amp;rdquo;. And since those practices are new, they might change a few times before settling. How do you ensure that after multiple months of migration, all repositories are in a similar state?</description>
    </item>
    
    <item>
      <title>Self-Documenting Makefile</title>
      <link>https://gellardo.github.io/blog/posts/2021-06-10-self-documenting-makefile/</link>
      <pubDate>Thu, 10 Jun 2021 16:07:25 +0200</pubDate>
      
      <guid>https://gellardo.github.io/blog/posts/2021-06-10-self-documenting-makefile/</guid>
      <description>&lt;p&gt;A short one i really liked and I want to document for future-me:
&lt;a href=&#34;https://marmelab.com/blog/2016/02/29/auto-documented-makefile.html&#34;&gt;Self-documenting &lt;code&gt;Makefile&lt;/code&gt;s&lt;/a&gt;.
Just add a new &lt;code&gt;help&lt;/code&gt; target and now you can comment all targets by using &lt;code&gt;## &amp;lt;comment&amp;gt;&lt;/code&gt; after the prerequisites.&lt;/p&gt;
&lt;p&gt;Having to remembering which targets are available in each project (and what they do) is not ideal and I have not used them enough to standardize on a certain naming.
Enter: a short article about &lt;a href=&#34;https://marmelab.com/blog/2016/02/29/auto-documented-makefile.html&#34;&gt;self-documenting Makefiles&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Playing With Rust and Wasm</title>
      <link>https://gellardo.github.io/blog/posts/2020-07-02-playing-with-rust-and-wasm/</link>
      <pubDate>Thu, 02 Jul 2020 21:52:04 +0200</pubDate>
      
      <guid>https://gellardo.github.io/blog/posts/2020-07-02-playing-with-rust-and-wasm/</guid>
      <description>I have read a lot about how Wasm is great for porting non-JS languages into the browser and maybe even into a general Lambda runtime. Also better security and ability to compile libraries into Wasm and use them in other languages. So I wanted to try it and document my experience using Rust+Wasm to build Game of Life using Wasm.
TLDR: If you want to learn a lot more than I can cover here, read the official rust+wasm introduction instead of watching me stumbling around here.</description>
    </item>
    
    <item>
      <title>Getting Hugo to run</title>
      <link>https://gellardo.github.io/blog/posts/2020-05-31-getting-hugo-to-run/</link>
      <pubDate>Sun, 31 May 2020 22:48:32 +0200</pubDate>
      
      <guid>https://gellardo.github.io/blog/posts/2020-05-31-getting-hugo-to-run/</guid>
      <description>&lt;p&gt;I wanted to have a really low friction way of practicing technical writing.
As my current employer mostly uses Blogs as PR, my first idea was to try blogging, but to start small without anyone seeing it.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>